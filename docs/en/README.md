<script>
setPagination(
    undefined,
    "/en/getting-started/installation"
);
</script>

# Introduction

---

## What is RTTIST?
RTTIST (pronounced /ˈɑː(r)tɪst/, like artist) is a TypeScript runtime reflection system inspired by the C#'s reflection.

It consists of several parts:
- [TypeGen - Metadata Generator](/en/typegen.md) - a standalone command-line tool that generates metadata from TypeScript types.
- [Runtime Library](/en/runtime.md) - a library that provides runtime reflection functionality.
- [Transformers](/en/transformers/transformers.md) - a set of transformers that extend the functionality of the TypeScript build/bundle tools.

To access base functionality, you only need to install the TypeGen and the runtime library. 
The transformers are optional. They are only needed if you want to use the extended functionality. 
TypeGen is a standalone noninvasive command-line tool. 
It does not depend on your project setup; it is completely decoupled from your build/bundle tool.

Here is a small example:
```typescript
import { Type } from "rttist";
import { Metadata } from "./metadata.typelib"; // this file is generated by TypeGen

const typeIController: Type = getType<IController>();

const controllerCtors = Promise.all(
        Metadata.getTypes()
        .filter(
            (type) =>
                type.isClass() &&
                !type.abstract &&
                type.exported &&
                type.isDerivedFrom(typeIController)
        )
        .map((type) => type.module.import().then(m => m?.[type.name]))
    );

const controllerInstances = controllerCtors.map(Ctor => new Ctor());
```

In this example, we get all exported non-abstract classes that are derived from the `IController` interface and create instances of them.

Module `metadata.typelib` is generated by the TypeGen. It exports `Metadata` object which is instance of the `MetadataLibrary`. It contains metadata for all types and modules in the project.



It is useful for many things, such as:
- serialization/deserialization,
- validation,
- dependency injection,
- frameworks and libraries.


## Alpha Warning!
This project is currently under development. \
There may still be major changes.

If you have any issues or questions or just want to give us feedback, join our [Discord](https://discord.gg/74qn6KPAUP).


## Supported Build/Bundle Tools

Thanks to RTTIST's flexible architecture, it seamlessly integrates with a variety of build and bundle tools.

However, it's important to note that certain build and bundle tools may come with limitations,
hindering the full breadth of RTTIST's capabilities.
For the ultimate experience, you have to use the TypeScript compiler directly.
Unlike other tools, the TypeScript compiler's TypeChecker empowers us to reflect inferred types, unlocking a deeper level of code understanding.

While we provide custom plugins for the most widely used tools, you have the flexibility to create your own if necessary.
We provide TS to TS compiler (npm: [@rttist/ts-loader-wasm](https://www.npmjs.com/package/@rttist/ts-loader-wasm)), implemented in Rust, that can be used in any plugin for any build/bundle tool in a loader.

For now, we provide plugins for:
- esbuild,
- SWC,
- Vite,
- ttypescript (work in progress).


## You Should Know
- TypeGen is a standalone cmd tool that generates metadata type library for static usage, and it is powered by TypeScript compiler API. When you generate metadata, you can simply import the metadata and use it in your project without any additional dependencies. 
- If you want to use `getType()` function, you have to use one of the transformers. Transformers just transforms `getType()` calls to static reads from metadata library.
- Using `typeof` operator in `getType<typeof something>()` is not supported by majority of transformers. You can use runtime evaluation `getType(someRuntimeValue)` if the value is class, function or some primitive type. `typeof` is supported only by transformer for TypeScript compiler.


## State of the Docs
This documentation is a work in progress. \
We are constantly working on improving it. \
If you have any questions or suggestions, feel free to use our [Discord](https://discord.gg/74qn6KPAUP) or create an issue or improving PR in the Docs [repo](https://github.com/rttist/docs).


[//]: # ()
[//]: # ()
[//]: # (## About)

[//]: # (<p style="text-align: justify">)

[//]: # (This project is all about runtime <strong>reflection</strong>. )

[//]: # (TypeScript itself contains rich type information but it is all dev time only. )

[//]: # (But TypeScript provide its compiler API, with access to type checker and ability to transform the code. )

[//]: # (Using this API we wrote a transformer plugin for TypeScript which generates runtime type information )

[//]: # (and modify your code slightly so you can reflect your types, even type parameters of classes, methods and functions.)

[//]: # (</p>)

[//]: # ()
[//]: # (<p style="clear: both;"></p>)

[//]: # ()
[//]: # (For more information check our website [rttist.org]&#40;https://rttist.org&#41; or docs [docs.rttist.org]&#40;https://docs.rttist.org&#41;.)

[//]: # ()
[//]: # ()
[//]: # (## Alpha)

[//]: # (This project is currently in alpha phase.)

[//]: # (There still may be some major changes, but no such changes are expected.)

[//]: # ()
[//]: # (If you participate in Alpha, use our discord mentioned in the [github.com/rttist/rttist]&#40;https://github.com/rttist/rttist&#41; README.)

[//]: # ()
[//]: # ()
[//]: # (## Showcase)

[//]: # ([//]: # &#40;TODO: List of StackBlitz examples&#41;)
[//]: # ()
[//]: # (```typescript)

[//]: # (import { getType, Type, PropertyInfo, MethodInfo } from "rttist";)

[//]: # ()
[//]: # (interface Employee {)

[//]: # (    name: string;)

[//]: # (    salary: number;)

[//]: # (    sayHello&#40;&#41;;)

[//]: # (    sayHello&#40;toSomebody: string&#41;;)

[//]: # (})

[//]: # ()
[//]: # (const type: Type = getType<Employee>&#40;&#41;;)

[//]: # ()
[//]: # (if &#40;type.isInterface&#40;&#41;&#41; {)

[//]: # (    const properties = type.getProperties&#40;&#41;.map&#40;&#40;prop: PropertyInfo&#41; => prop.name&#41;;)

[//]: # (    const methods = type.getMethods&#40;&#41;.map&#40;&#40;method: MethodInfo&#41; => method.name&#41;;)

[//]: # ()
[//]: # (    console.log&#40;properties&#41;; // > [ name, salary ])

[//]: # (    console.log&#40;methods&#41;; // > [ sayHello ])

[//]: # ()
[//]: # (    const sayHelloMethod: MethodInfo = type.getMethods&#40;&#41;.find&#40;m => m.name === "sayHello"&#41;;)

[//]: # (    const signatures = sayHelloMethod.getSignatures&#40;&#41;)

[//]: # (        .map&#40;sig => {)

[//]: # (            const parameters = sig.getParameters&#40;&#41;)

[//]: # (                .map&#40;param => param.name + ": " + param.type.name&#41;;)

[//]: # ()
[//]: # (            return `sayHello&#40;${parameters.join&#40;", "&#41;}&#41;`)

[//]: # (        }&#41;;)

[//]: # ()
[//]: # (    console.log&#40;signatures&#41;; // > [ sayHello&#40;&#41;, sayHello&#40;toSomebody: string&#41; ])

[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (## Performance & Compatibility)

[//]: # (**Performance**)

[//]: # ()
[//]: # (Because of generic type parameters, the source code is modified. )

[//]: # (Several function calls and variable declarations are added to the source code which will make your program a little slower.)

[//]: # ()
[//]: # (**Compatibility**)

[//]: # ()
[//]: # (> This package introduces real generic classes, so for example class `Logger` is not the same class as `Logger<User>`!)

[//]: # (> )

[//]: # (> `Logger<User>` is subclass of `Logger`.)

[//]: # ()
[//]: # (To fully support **generic class** type parameters, all generic classes are wrapped by our classes which change default behavior a little.)

[//]: # (If you use `instanceof` operator, there will be no problem. )

[//]: # (If you access constructors of class instances from their prototype, you'll get different constructor than you expect.)

[//]: # ()
[//]: # (Each specific generic class is a subclass of your generic class declaration.)

[//]: # ()
[//]: # (Lets have any generic class.)

[//]: # (```typescript)

[//]: # (export class Logger<TContext> {)

[//]: # (	)
[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (If you use this class like this:)

[//]: # (```typescript)

[//]: # (const logger = new Logger<User>&#40;&#41;;)

[//]: # (```)

[//]: # (new class `Logger<User>` will be created and instantiated at runtime instead of base `Logger` class. )

[//]: # (It's the same behavior as C#, Java and other languages have &#40;they just generate those classes at compile time&#41;.)

[//]: # ()
[//]: # ()
[//]: # (```typescript)

[//]: # (class Logger<TContext> // This is a declaration of generic type)

[//]: # ({)

[//]: # (	log&#40;...args: any[]&#41;)

[//]: # (	{)

[//]: # (		console.log&#40;...args&#41;;)

[//]: # (	})

[//]: # (})

[//]: # ()
[//]: # (const logger = new Logger<User>&#40;&#41;; // Logger<User> is generic class, inheriting from Logger<T> declaration)

[//]: # ()
[//]: # (// This will not work as expected)

[//]: # (if &#40;Object.getPrototypeOf&#40;logger&#41;.constructor === Logger&#41; // false)

[//]: # ({)

[//]: # (	// ...)

[//]: # (})



[//]: # ()
[//]: # (// This is OK)

[//]: # (if &#40;logger instanceof Logger&#41; // true)

[//]: # ({)

[//]: # (	// ...)

[//]: # (})

[//]: # ()
[//]: # (const userLoggerType: Type = getType<Logger<User>>&#40;&#41;;)

[//]: # (const loggerType: Type = getType&#40;Logger&#41;;)

[//]: # ()
[//]: # (if &#40;userLoggerType.isClass&#40;&#41; && userLoggerType.isSubclassOf&#40;loggerType&#41;)

[//]: # (	&& userLoggerType.isGenericType&#40;&#41;)

[//]: # (	&& userLoggerType.genericTypeDefinition.is&#40;loggerType&#41;)

[//]: # (	&& userLoggerType.genericTypeDefinition.isGenericType&#40;&#41;)

[//]: # (	&& userLoggerType.genericTypeDefinition.isGenericTypeDefinition&#40;&#41;&#41; // true)

[//]: # ({)

[//]: # (	// ...)

[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (In case this is a problem for you, let us know in [this issue]&#40;https://github.com/rttist/rttist/issues/8&#41;.)

[//]: # ()

## License

This project is licensed under the MIT license.
